<!doctype html>
<html>
<head>
  <meta charset="utf-8">
  <title>3D People Tiles Visualization</title>
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <style>
    body { font-family: Arial, Helvetica, sans-serif; margin:0; overflow:hidden; background:#111; color:#fff; }
    #container { position: absolute; width: 100%; height: 100%; }
    .element {
      width: 160px; height: 190px;
      box-sizing: border-box;
      padding: 8px;
      border-radius: 8px;
      box-shadow: 0 6px 18px rgba(0,0,0,0.6);
      color: #fff;
      text-align: left;
      font-size: 12px;
      overflow: hidden;
      transition: transform 0.3s ease;
    }
    .element:hover {
      transform: scale(1.05);
      z-index: 100;
      position: relative;
    }
    .photo {
      width: 100%;
      height: 88px;
      object-fit: cover;
      border-radius: 6px;
      margin-bottom: 8px;
      background: rgba(255,255,255,0.08);
    }
    .name { font-weight:700; font-size:14px; margin-bottom:4px; }
    .meta { font-size:11px; opacity:0.95; margin-bottom:2px; }
    .controls {
      position: absolute; left: 12px; top: 12px; z-index: 5;
      background: rgba(255,255,255,0.95); color:#000; padding: 10px; border-radius:8px;
      font-size:13px;
      box-shadow: 0 4px 12px rgba(0,0,0,0.3);
    }
    .controls button{ 
      margin:4px; 
      padding: 6px 12px;
      background: #4285f4;
      color: white;
      border: none;
      border-radius: 4px;
      cursor: pointer;
      font-size: 12px;
    }
    .controls button:hover {
      background: #3367d6;
    }
    .gsi-button-wrap { margin-bottom:8px; }
    .status {
      margin-top: 8px;
      padding: 4px;
      background: #f5f5f5;
      border-radius: 4px;
      font-size: 12px;
    }
    .info {
      margin-top: 8px;
      padding: 4px;
      background: #e8f4fd;
      border-radius: 4px;
      font-size: 11px;
      color: #0c5460;
    }
    /* small responsive tweak */
    @media (max-width:600px){
      .controls{ width: 90%; left: 50%; transform: translateX(-50%); }
      .controls button{ display: block; width: 100%; margin: 4px 0; }
    }
    .loading {
      position: absolute;
      top: 50%;
      left: 50%;
      transform: translate(-50%, -50%);
      color: white;
      font-size: 18px;
      text-align: center;
    }
  </style>
</head>
<body>
  <div id="container"></div>
  <div id="loading" class="loading">Loading 3D visualization...</div>

  <div class="controls" id="controls" aria-live="polite" style="display: none;">
    <div class="gsi-button-wrap">
      <div id="g_id_signin"></div>
    </div>

    <div>
      <button onclick="transformTo('table')">Table (20×10)</button>
      <button onclick="transformTo('sphere')">Sphere</button>
      <button onclick="transformTo('helix')">Double Helix</button>
      <button onclick="transformTo('grid')">Grid (5×4×10)</button>
      <button onclick="reloadData()">Reload Data</button>
      <button onclick="signOut()">Sign Out</button>
    </div>

    <div class="status">
      <strong>Status:</strong> <span id="userEmail">not signed in</span>
    </div>
    
    <div class="info">
      <strong>Info:</strong> <span id="dataInfo">No data loaded</span>
    </div>
  </div>

  <!-- Load Three.js first -->
  <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r149/three.min.js"></script>
  
  <!-- Then load the rest of the scripts -->
  <script>
  // Wait for Three.js to load before defining dependent classes
  (function() {
    if (typeof THREE === 'undefined') {
      console.error('Three.js not loaded yet');
      return;
    }
    
    // CSS3DRenderer for Three.js r149
    THREE.CSS3DObject = function ( element ) {
      THREE.Object3D.call( this );
      this.element = element;
      this.element.style.position = 'absolute';
      this.element.style.pointerEvents = 'auto';
      this.addEventListener( 'removed', function () {
        this.traverse( function ( object ) {
          if ( object.element instanceof Element && object.element.parentNode !== null ) {
            object.element.parentNode.removeChild( object.element );
          }
        } );
      } );
    };
    THREE.CSS3DObject.prototype = Object.create( THREE.Object3D.prototype );
    THREE.CSS3DObject.prototype.constructor = THREE.CSS3DObject;
    
    THREE.CSS3DSprite = function ( element ) {
      THREE.CSS3DObject.call( this, element );
    };
    THREE.CSS3DSprite.prototype = Object.create( THREE.CSS3DObject.prototype );
    THREE.CSS3DSprite.prototype.constructor = THREE.CSS3DSprite;
    
    THREE.CSS3DRenderer = function () {
      var _this = this;
      var _width, _height;
      var _widthHalf, _heightHalf;
      var _matrix = new THREE.Matrix4();
      var domElement = document.createElement( 'div' );
      domElement.style.overflow = 'hidden';
      this.domElement = domElement;
      
      this.setSize = function ( width, height ) {
        _width = width;
        _height = height;
        _widthHalf = _width / 2;
        _heightHalf = _height / 2;
        domElement.style.width = width + 'px';
        domElement.style.height = height + 'px';
      };
      
      var epsilon = function ( value ) {
        return Math.abs( value ) < 1e-10 ? 0 : value;
      };
      
      var getCameraCSSMatrix = function ( matrix ) {
        var elements = matrix.elements;
        return 'matrix3d(' +
          epsilon( elements[ 0 ] ) + ',' +
          epsilon( - elements[ 1 ] ) + ',' +
          epsilon( elements[ 2 ] ) + ',' +
          epsilon( elements[ 3 ] ) + ',' +
          epsilon( elements[ 4 ] ) + ',' +
          epsilon( - elements[ 5 ] ) + ',' +
          epsilon( elements[ 6 ] ) + ',' +
          epsilon( elements[ 7 ] ) + ',' +
          epsilon( elements[ 8 ] ) + ',' +
          epsilon( - elements[ 9 ] ) + ',' +
          epsilon( elements[ 10 ] ) + ',' +
          epsilon( elements[ 11 ] ) + ',' +
          epsilon( elements[ 12 ] ) + ',' +
          epsilon( - elements[ 13 ] ) + ',' +
          epsilon( elements[ 14 ] ) + ',' +
          epsilon( elements[ 15 ] ) +
        ')';
      };
      
      var getObjectCSSMatrix = function ( matrix ) {
        var elements = matrix.elements;
        return 'translate3d(-50%,-50%,0) matrix3d(' +
          epsilon( elements[ 0 ] ) + ',' +
          epsilon( elements[ 1 ] ) + ',' +
          epsilon( elements[ 2 ] ) + ',' +
          epsilon( elements[ 3 ] ) + ',' +
          epsilon( - elements[ 4 ] ) + ',' +
          epsilon( - elements[ 5 ] ) + ',' +
          epsilon( - elements[ 6 ] ) + ',' +
          epsilon( - elements[ 7 ] ) + ',' +
          epsilon( elements[ 8 ] ) + ',' +
          epsilon( elements[ 9 ] ) + ',' +
          epsilon( elements[ 10 ] ) + ',' +
          epsilon( elements[ 11 ] ) + ',' +
          epsilon( elements[ 12 ] ) + ',' +
          epsilon( elements[ 13 ] ) + ',' +
          epsilon( elements[ 14 ] ) + ',' +
          epsilon( elements[ 15 ] ) +
        ')';
      };
      
      var renderObject = function ( object, scene, camera ) {
        if ( object instanceof THREE.CSS3DObject ) {
          var style;
          if ( object instanceof THREE.CSS3DSprite ) {
            var angle = Math.atan2( object.position.x - camera.position.x, object.position.z - camera.position.z );
            var style = 'rotateY(' + angle + 'rad)';
            if ( object.element.style.transform !== style ) {
              object.element.style.transform = style;
            }
            style = 'translate(' + ( - _widthHalf + object.position.x * _widthHalf ) + 'px,' + ( - _heightHalf - object.position.y * _heightHalf ) + 'px)';
          } else {
            _matrix.copy( camera.matrixWorldInverse );
            _matrix.multiply( object.matrixWorld );
            style = getObjectCSSMatrix( _matrix );
          }
          if ( object.element.style.transform !== style ) {
            object.element.style.transform = style;
          }
          if ( object.element.parentNode !== domElement ) {
            domElement.appendChild( object.element );
          }
        }
        for ( var i = 0, l = object.children.length; i < l; i ++ ) {
          renderObject( object.children[ i ], scene, camera );
        }
      };
      
      this.render = function ( scene, camera ) {
        scene.updateMatrixWorld();
        if ( camera.parent === null ) camera.updateMatrixWorld();
        _matrix.copy( camera.matrixWorldInverse );
        _matrix.multiply( scene.matrixWorld );
        renderObject( scene, scene, camera );
      };
    };
    
    // TrackballControls for Three.js r149
    THREE.TrackballControls = function ( object, domElement ) {
      var _this = this;
      var STATE = { NONE: - 1, ROTATE: 0, ZOOM: 1, PAN: 2, TOUCH_ROTATE: 3, TOUCH_ZOOM_PAN: 4 };
      this.object = object;
      this.domElement = ( domElement !== undefined ) ? domElement : document;
      this.enabled = true;
      this.screen = { left: 0, top: 0, width: 0, height: 0 };
      this.rotateSpeed = 1.0;
      this.zoomSpeed = 1.2;
      this.panSpeed = 0.3;
      this.noRotate = false;
      this.noZoom = false;
      this.noPan = false;
      this.staticMoving = false;
      this.dynamicDampingFactor = 0.2;
      this.minDistance = 0;
      this.maxDistance = Infinity;
      this.keys = [ 65 /*A*/, 83 /*S*/, 68 /*D*/ ];
      var EPS = 0.000001;
      var lastPosition = new THREE.Vector3();
      var _state = STATE.NONE,
      _prevState = STATE.NONE,
      _eye = new THREE.Vector3(),
      _movePrev = new THREE.Vector2(),
      _moveCurr = new THREE.Vector2(),
      _lastAxis = new THREE.Vector3(),
      _lastAngle = 0,
      _zoomStart = new THREE.Vector2(),
      _zoomEnd = new THREE.Vector2(),
      _touchZoomDistanceStart = 0,
      _touchZoomDistanceEnd = 0,
      _panStart = new THREE.Vector2(),
      _panEnd = new THREE.Vector2();
      this.target = new THREE.Vector3();
      var changeEvent = { type: 'change' };
      var startEvent = { type: 'start' };
      var endEvent = { type: 'end' };
      
      this.rotateCamera = (function() {
        var axis = new THREE.Vector3(),
          quaternion = new THREE.Quaternion(),
          eyeDirection = new THREE.Vector3(),
          objectUpDirection = new THREE.Vector3(),
          objectSidewaysDirection = new THREE.Vector3(),
          moveDirection = new THREE.Vector3(),
          angle;
        return function rotateCamera() {
          moveDirection.set( _moveCurr.x - _movePrev.x, _moveCurr.y - _movePrev.y, 0 );
          angle = moveDirection.length();
          if ( angle ) {
            _eye.copy( _this.object.position ).sub( _this.target );
            eyeDirection.copy( _eye ).normalize();
            objectUpDirection.copy( _this.object.up ).normalize();
            objectSidewaysDirection.crossVectors( objectUpDirection, eyeDirection ).normalize();
            objectUpDirection.setLength( _moveCurr.y - _movePrev.y );
            objectSidewaysDirection.setLength( _moveCurr.x - _movePrev.x );
            moveDirection.copy( objectUpDirection.add( objectSidewaysDirection ) );
            axis.crossVectors( moveDirection, _eye ).normalize();
            angle *= _this.rotateSpeed;
            quaternion.setFromAxisAngle( axis, angle );
            _eye.applyQuaternion( quaternion );
            _this.object.up.applyQuaternion( quaternion );
            _lastAxis.copy( axis );
            _lastAngle = angle;
          } else if ( ! _this.staticMoving && _lastAngle ) {
            _lastAngle *= Math.sqrt( 1.0 - _this.dynamicDampingFactor );
            _eye.copy( _this.object.position ).sub( _this.target );
            quaternion.setFromAxisAngle( _lastAxis, _lastAngle );
            _eye.applyQuaternion( quaternion );
            _this.object.up.applyQuaternion( quaternion );
          }
          _movePrev.copy( _moveCurr );
        };
      }());
      
      this.zoomCamera = function () {
        var factor;
        if ( _state === STATE.TOUCH_ZOOM_PAN ) {
          factor = _touchZoomDistanceStart / _touchZoomDistanceEnd;
          _touchZoomDistanceStart = _touchZoomDistanceEnd;
          _eye.multiplyScalar( factor );
        } else {
          factor = 1.0 + ( _zoomEnd.y - _zoomStart.y ) * _this.zoomSpeed;
          if ( factor !== 1.0 && factor > 0.0 ) {
            _eye.multiplyScalar( factor );
            if ( _this.staticMoving ) {
              _zoomStart.copy( _zoomEnd );
            } else {
              _zoomStart.y += ( _zoomEnd.y - _zoomStart.y ) * this.dynamicDampingFactor;
            }
          }
        }
      };
      
      this.panCamera = (function() {
        var mouseChange = new THREE.Vector2(),
          objectUp = new THREE.Vector3(),
          pan = new THREE.Vector3();
        return function panCamera() {
          mouseChange.copy( _panEnd ).sub( _panStart );
          if ( mouseChange.lengthSq() ) {
            mouseChange.multiplyScalar( _eye.length() * _this.panSpeed );
            pan.copy( _eye ).cross( _this.object.up ).setLength( mouseChange.x );
            pan.add( objectUp.copy( _this.object.up ).setLength( mouseChange.y ) );
            _this.object.position.add( pan );
            _this.target.add( pan );
            if ( _this.staticMoving ) {
              _panStart.copy( _panEnd );
            } else {
              _panStart.add( mouseChange.subVectors( _panEnd, _panStart ).multiplyScalar( _this.dynamicDampingFactor ) );
            }
          }
        };
      }());
      
      this.checkDistances = function () {
        if ( ! _this.noZoom || ! _this.noPan ) {
          if ( _eye.lengthSq() > _this.maxDistance * _this.maxDistance ) {
            _this.object.position.addVectors( _this.target, _eye.setLength( _this.maxDistance ) );
            _zoomStart.copy( _zoomEnd );
          }
          if ( _eye.lengthSq() < _this.minDistance * _this.minDistance ) {
            _this.object.position.addVectors( _this.target, _eye.setLength( _this.minDistance ) );
            _zoomStart.copy( _zoomEnd );
          }
        }
      };
      
      this.update = function () {
        _eye.subVectors( _this.object.position, _this.target );
        if ( ! _this.noRotate ) {
          _this.rotateCamera();
        }
        if ( ! _this.noZoom ) {
          _this.zoomCamera();
        }
        if ( ! _this.noPan ) {
          _this.panCamera();
        }
        _this.object.position.addVectors( _this.target, _eye );
        _this.checkDistances();
        _this.object.lookAt( _this.target );
        if ( lastPosition.distanceToSquared( _this.object.position ) > EPS ) {
          _this.dispatchEvent( changeEvent );
          lastPosition.copy( _this.object.position );
        }
      };
      
      this.reset = function () {
        _state = STATE.NONE;
        _prevState = STATE.NONE;
        _this.target.copy( _this.target0 );
        _this.object.position.copy( _this.position0 );
        _this.object.up.copy( _this.up0 );
        _eye.subVectors( _this.object.position, _this.target );
        _this.object.lookAt( _this.target );
        _this.dispatchEvent( changeEvent );
        lastPosition.copy( _this.object.position );
      };
      
      this.handleResize = function () {
        if ( this.domElement === document ) {
          this.screen.left = 0;
          this.screen.top = 0;
          this.screen.width = window.innerWidth;
          this.screen.height = window.innerHeight;
        } else {
          var box = this.domElement.getBoundingClientRect();
          this.screen.left = box.left + document.body.scrollLeft;
          this.screen.top = box.top + document.body.scrollTop;
          this.screen.width = box.width;
          this.screen.height = box.height;
        }
      };
      
      var getMouseOnScreen = (function () {
        var vector = new THREE.Vector2();
        return function getMouseOnScreen( pageX, pageY ) {
          vector.set(
            ( pageX - _this.screen.left ) / _this.screen.width,
            ( pageY - _this.screen.top ) / _this.screen.height
          );
          return vector;
        };
      }());
      
      var getMouseOnCircle = (function () {
        var vector = new THREE.Vector2();
        return function getMouseOnCircle( pageX, pageY ) {
          vector.set(
            ( ( pageX - _this.screen.width * 0.5 - _this.screen.left ) / ( _this.screen.width * 0.5 ) ),
            ( ( _this.screen.height + 2 * ( _this.screen.top - pageY ) ) / _this.screen.width )
          );
          return vector;
        };
      }());
      
      this.handleEvent = function ( event ) {
        if ( typeof this[ event.type ] == 'function' ) {
          this[ event.type ]( event );
        }
      };
      
      var mousedown = function ( event ) {
        if ( _this.enabled === false ) return;
        event.preventDefault();
        if ( event.button === 0 ) {
          _state = STATE.ROTATE;
        } else if ( event.button === 1 ) {
          _state = STATE.ZOOM;
        } else if ( event.button === 2 ) {
          _state = STATE.PAN;
        }
        _prevState = _state;
        if ( _state === STATE.ROTATE && ! _this.noRotate ) {
          _moveCurr.copy( getMouseOnCircle( event.pageX, event.pageY ) );
          _movePrev.copy( _moveCurr );
        } else if ( _state === STATE.ZOOM && ! _this.noZoom ) {
          _zoomStart.copy( getMouseOnScreen( event.pageX, event.pageY ) );
          _zoomEnd.copy( _zoomStart );
        } else if ( _state === STATE.PAN && ! _this.noPan ) {
          _panStart.copy( getMouseOnScreen( event.pageX, event.pageY ) );
          _panEnd.copy( _panStart );
        }
        document.addEventListener( 'mousemove', mousemove, false );
        document.addEventListener( 'mouseup', mouseup, false );
        _this.dispatchEvent( startEvent );
      };
      
      var mousemove = function ( event ) {
        if ( _this.enabled === false ) return;
        event.preventDefault();
        if ( _state === STATE.ROTATE && ! _this.noRotate ) {
          _moveCurr.copy( getMouseOnCircle( event.pageX, event.pageY ) );
        } else if ( _state === STATE.ZOOM && ! _this.noZoom ) {
          _zoomEnd.copy( getMouseOnScreen( event.pageX, event.pageY ) );
        } else if ( _state === STATE.PAN && ! _this.noPan ) {
          _panEnd.copy( getMouseOnScreen( event.pageX, event.pageY ) );
        }
      };
      
      var mouseup = function ( event ) {
        if ( _this.enabled === false ) return;
        event.preventDefault();
        _state = STATE.NONE;
        document.removeEventListener( 'mousemove', mousemove );
        document.removeEventListener( 'mouseup', mouseup );
        _this.dispatchEvent( endEvent );
      };
      
      this.domElement.addEventListener( 'contextmenu', function ( event ) { event.preventDefault(); }, false );
      this.domElement.addEventListener( 'mousedown', mousemove, false );
      this.handleResize();
      window.addEventListener( 'resize', this.handleResize, false );
    };
    
    THREE.TrackballControls.prototype = Object.create( THREE.EventDispatcher.prototype );
    THREE.TrackballControls.prototype.constructor = THREE.TrackballControls;
    
    console.log('Three.js extensions loaded successfully');
    
    // Now that Three.js is ready, initialize our app
    initApp();
  })();
  
  /* ----------------- CONFIG ----------------- */
  const CLIENT_ID = '330173954188-eighpf5lec4lccknriqa5gkt19mjv98e.apps.googleusercontent.com';
  const SPREADSHEET_ID = '13-qIqTXm0Ilp-PsWVcxUX9QpxHi_KfjgXCoKhqfQfAY';
  
  /* ----------------- Auth State ----------------- */
  let accessToken = null;
  let currentUser = null;
  
  /* ----------------- THREE.JS / Scene Setup ----------------- */
  let camera, scene, renderer, controls;
  let objects = [];
  let targets = { table: [], sphere: [], helix: [], grid: [] };
  
  function initApp() {
    console.log('Initializing 3D visualization...');
    initThree();
    animate();
    
    // Load Google Identity Services
    loadGoogleSignIn();
    
    // Show controls
    document.getElementById('controls').style.display = 'block';
    document.getElementById('loading').style.display = 'none';
    
    // Load demo data initially
    setTimeout(() => {
      loadData(null); // Load sample data first
    }, 500);
  }
  
  function initThree() {
    const container = document.getElementById('container');
    camera = new THREE.PerspectiveCamera(40, window.innerWidth / window.innerHeight, 1, 10000);
    camera.position.z = 3000;
    scene = new THREE.Scene();
    renderer = new THREE.CSS3DRenderer();
    renderer.setSize(window.innerWidth, window.innerHeight);
    renderer.domElement.style.position = 'absolute';
    container.appendChild(renderer.domElement);
    controls = new THREE.TrackballControls(camera, renderer.domElement);
    controls.rotateSpeed = 0.5;
    controls.minDistance = 500;
    controls.maxDistance = 6000;
    window.addEventListener('resize', onWindowResize, false);
  }
  
  function onWindowResize() {
    camera.aspect = window.innerWidth / window.innerHeight;
    camera.updateProjectionMatrix();
    renderer.setSize(window.innerWidth, window.innerHeight);
    controls.handleResize();
  }
  
  function animate() {
    requestAnimationFrame(animate);
    TWEEN.update();
    controls.update();
    renderer.render(scene, camera);
  }
  
  /* ----------------- Tile creation ----------------- */
  function createTile(row, idx) {
    const el = document.createElement('div');
    el.className = 'element';
    const net = parseNetWorth(row['Net Worth'] || row['NetWorth'] || row['net worth'] || '');
    let bg = '#555';
    if (net < 100000) bg = '#c0392b';
    else if (net <= 200000) bg = '#d35400';
    else bg = '#27ae60';
    el.style.background = bg;
  
    const img = document.createElement('img');
    img.className = 'photo';
    img.alt = row['Name'] || '';
    img.src = row['Photo'] || 'https://via.placeholder.com/160x88?text=No+Photo';
    el.appendChild(img);
  
    const nameDiv = document.createElement('div');
    nameDiv.className = 'name';
    nameDiv.textContent = row['Name'] || '';
    el.appendChild(nameDiv);
  
    const ageDiv = document.createElement('div');
    ageDiv.className = 'meta';
    ageDiv.textContent = 'Age: ' + (row['Age'] || '');
    el.appendChild(ageDiv);
  
    const countryDiv = document.createElement('div');
    countryDiv.className = 'meta';
    countryDiv.textContent = 'Country: ' + (row['Country'] || '');
    el.appendChild(countryDiv);
  
    const interestDiv = document.createElement('div');
    interestDiv.className = 'meta';
    interestDiv.textContent = 'Interest: ' + (row['Interest'] || '');
    el.appendChild(interestDiv);
  
    const nwDiv = document.createElement('div');
    nwDiv.className = 'meta';
    nwDiv.textContent = 'Net Worth: ' + (row['Net Worth'] || row['NetWorth'] || '');
    el.appendChild(nwDiv);
  
    const objectCSS = new THREE.CSS3DObject(el);
    objectCSS.position.x = Math.random() * 4000 - 2000;
    objectCSS.position.y = Math.random() * 4000 - 2000;
    objectCSS.position.z = Math.random() * 4000 - 2000;
    scene.add(objectCSS);
    objects.push(objectCSS);
  }
  
  function parseNetWorth(s) {
    if (!s) return 0;
    s = String(s).trim();
    let mult = 1;
    if (/[kK]$/.test(s)) { mult = 1e3; s = s.replace(/[kK]$/, ''); }
    if (/[mM]$/.test(s)) { mult = 1e6; s = s.replace(/[mM]$/, ''); }
    const n = parseFloat(s.replace(/[^0-9.]/g, '')) || 0;
    return n * mult;
  }
  
  /* ----------------- Layout builders ----------------- */
  function buildTableTargets(count) {
    targets.table = [];
    const cols = 20, rows = 10;
    const spacingX = 180, spacingY = 210;
    const offsetX = (cols - 1) * spacingX / 2;
    const offsetY = (rows - 1) * spacingY / 2;
    for (let i = 0; i < count; i++) {
      const col = i % cols;
      const row = Math.floor(i / cols);
      const obj = new THREE.Object3D();
      obj.position.x = col * spacingX - offsetX;
      obj.position.y = -(row * spacingY - offsetY);
      obj.position.z = 0;
      targets.table.push(obj);
    }
  }
  
  function buildSphereTargets(count) {
    targets.sphere = [];
    const radius = 900;
    for (let i = 0; i < count; i++) {
      const phi = Math.acos(-1 + (2 * i) / count);
      const theta = Math.sqrt(count * Math.PI) * phi;
      const obj = new THREE.Object3D();
      obj.position.x = radius * Math.cos(theta) * Math.sin(phi);
      obj.position.y = radius * Math.sin(theta) * Math.sin(phi);
      obj.position.z = radius * Math.cos(phi);
      targets.sphere.push(obj);
    }
  }
  
  function buildDoubleHelixTargets(count) {
    targets.helix = [];
    const separation = 70;
    const spacingY = 24;
    const totalPerStrand = Math.ceil(count / 2);
    const totalHeight = totalPerStrand * spacingY;
    for (let i = 0; i < count; i++) {
      const strand = i % 2;
      const idx = Math.floor(i / 2);
      const angle = idx * 0.4 + (strand === 0 ? 0 : Math.PI);
      const obj = new THREE.Object3D();
      obj.position.x = Math.cos(angle) * separation;
      obj.position.z = Math.sin(angle) * separation;
      obj.position.y = -(idx * spacingY) + (totalHeight / 2);
      targets.helix.push(obj);
    }
  }
  
  function buildGridTargets(count) {
    targets.grid = [];
    const gx = 5, gy = 4, gz = 10;
    const spacing = 240;
    const offsetX = (gx - 1) * spacing / 2;
    const offsetY = (gy - 1) * spacing / 2;
    const offsetZ = (gz - 1) * spacing / 2;
    for (let i = 0; i < count; i++) {
      const x = i % gx;
      const y = Math.floor(i / gx) % gy;
      const z = Math.floor(i / (gx * gy)) % gz;
      const obj = new THREE.Object3D();
      obj.position.x = x * spacing - offsetX;
      obj.position.y = -(y * spacing - offsetY);
      obj.position.z = z * spacing - offsetZ;
      targets.grid.push(obj);
    }
  }
  
  function transformTo(layout) {
    const arr = targets[layout];
    if (!arr) return;
    for (let i = 0; i < objects.length; i++) {
      const obj = objects[i];
      const tgt = arr[i];
      if (!tgt) continue;
      new TWEEN.Tween(obj.position).to({ x: tgt.position.x, y: tgt.position.y, z: tgt.position.z }, 1300).easing(TWEEN.Easing.Exponential.InOut).start();
      new TWEEN.Tween(obj.rotation).to({ x: 0, y: 0, z: 0 }, 1300).easing(TWEEN.Easing.Exponential.InOut).start();
    }
  }
  
  /* ----------------- Data loading ----------------- */
  async function loadSheetsUsingToken(accessToken) {
    console.log('Trying to load sheet with token...');
    
    // Try different sheet names
    const sheetNames = [
      'Data Template', // Your sheet name
      'Sheet1',
      'Sheet 1',
      'Sheet 2',
      'Sheet 3',
      'Sheet4'
    ];
    
    let lastError = null;
    
    for (const sheetName of sheetNames) {
      try {
        const range = `${sheetName}!A1:F999`;
        console.log(`Trying range: ${range}`);
        
        const url = `https://sheets.googleapis.com/v4/spreadsheets/${SPREADSHEET_ID}/values/${encodeURIComponent(range)}?majorDimension=ROWS`;
        const res = await fetch(url, { 
          headers: { 
            Authorization: 'Bearer ' + accessToken,
            'Content-Type': 'application/json'
          } 
        });
        
        if (!res.ok) {
          const errorText = await res.text();
          console.log(`Failed with sheet name "${sheetName}": ${res.status}`);
          lastError = new Error(`Sheets API error ${res.status}: ${errorText}`);
          continue; // Try next sheet name
        }
        
        const json = await res.json();
        console.log(`Success with sheet name: "${sheetName}"`);
        
        const rows = json.values || [];
        if (rows.length < 1) {
          console.log('No data found');
          return [];
        }
        
        const headers = rows[0];
        // Filter out empty rows - only include rows that have at least a name
        const data = rows.slice(1)
          .map(r => {
            const obj = {};
            for (let i = 0; i < headers.length; i++) {
              obj[headers[i]] = r[i] || '';
            }
            return obj;
          })
          .filter(row => {
            // Only include rows that have at least a name
            return row['Name'] && row['Name'].trim() !== '';
          });
        
        console.log(`Total rows from sheet: ${rows.length - 1}`);
        console.log(`Filtered rows with data: ${data.length}`);
        
        return data;
        
      } catch (err) {
        lastError = err;
        continue;
      }
    }
    
    throw lastError || new Error('Could not find valid sheet');
  }
  
  async function loadData(token) {
    try {
      let data = [];
      let source = '';
      
      // Try Sheets API first if we have a token
      if (token) {
        console.log('Loading from Google Sheets...');
        data = await loadSheetsUsingToken(token);
        source = 'Google Sheets';
      }
      
      // If no data from Sheets, use sample data
      if (!data || data.length === 0) {
        console.log('Using sample data...');
        data = createSampleData(50);
        source = 'Demo Data';
        document.getElementById('userEmail').textContent = 'Demo Mode (sample data)';
      } else {
        document.getElementById('userEmail').textContent = currentUser ? currentUser.email : 'Loaded from Google Sheets';
      }
  
      // Clear previous objects
      objects.forEach(o => scene.remove(o));
      objects = [];
  
      // Create tiles
      data.forEach((row, idx) => createTile(row, idx));
  
      // Build layouts
      const count = objects.length;
      buildTableTargets(count);
      buildSphereTargets(count);
      buildDoubleHelixTargets(count);
      buildGridTargets(count);
  
      // Start with table layout
      transformTo('table');
      
      // Update info display
      document.getElementById('dataInfo').textContent = `${count} people loaded from ${source}`;
      console.log(`Total loaded rows: ${count} from ${source}`);
      
    } catch (err) {
      console.error('loadData error:', err);
      
      // Fallback to sample data on error
      console.log('Falling back to sample data...');
      const sampleData = createSampleData(50);
      document.getElementById('userEmail').textContent = 'Demo Mode (fallback data)';
      
      objects.forEach(o => scene.remove(o));
      objects = [];
      sampleData.forEach((row, idx) => createTile(row, idx));
      
      const count = objects.length;
      buildTableTargets(count);
      buildSphereTargets(count);
      buildDoubleHelixTargets(count);
      buildGridTargets(count);
      transformTo('table');
      
      document.getElementById('dataInfo').textContent = `${count} people loaded (fallback data)`;
    }
  }
  
  function createSampleData(count) {
    const data = [];
    const names = ['John Doe', 'Jane Smith', 'Robert Johnson', 'Emily Brown', 'Michael Wilson', 
                   'Sarah Davis', 'David Miller', 'Lisa Taylor', 'James Anderson', 'Karen Thomas'];
    const countries = ['USA', 'UK', 'Canada', 'Australia', 'Germany', 'France', 'Japan', 'Brazil', 'India', 'China'];
    const interests = ['Technology', 'Finance', 'Art', 'Science', 'Sports', 'Music', 'Travel', 'Food', 'Photography', 'Gaming'];
    
    for (let i = 0; i < count; i++) {
      const netWorth = (10 + Math.random() * 290).toFixed(1);
      const netWorthText = Math.random() > 0.5 ? `$${netWorth}K` : `$${(netWorth / 1000).toFixed(2)}M`;
      
      data.push({
        Name: `${names[i % names.length]} ${i + 1}`,
        Age: Math.floor(20 + Math.random() * 50),
        Country: countries[i % countries.length],
        Interest: interests[i % interests.length],
        'Net Worth': netWorthText,
        Photo: `https://picsum.photos/seed/${i + 100}/160/88`
      });
    }
    return data;
  }
  
  /* ----------------- Google Sign-In & Auth ----------------- */
  function loadGoogleSignIn() {
    const script = document.createElement('script');
    script.src = 'https://accounts.google.com/gsi/client';
    script.async = true;
    script.defer = true;
    script.onload = function() {
      initGoogleSignIn();
    };
    document.head.appendChild(script);
  }
  
  function initGoogleSignIn() {
    if (!window.google) {
      setTimeout(initGoogleSignIn, 100);
      return;
    }
    
    console.log('Initializing Google Sign-In...');
    
    google.accounts.id.initialize({
      client_id: CLIENT_ID,
      callback: handleCredentialResponse,
      auto_select: false,
      ux_mode: 'popup'
    });
    
    google.accounts.id.renderButton(
      document.getElementById('g_id_signin'),
      { 
        theme: 'outline', 
        size: 'large', 
        type: 'standard',
        text: 'signin_with',
        shape: 'rectangular'
      }
    );
    
    google.accounts.id.prompt();
  }
  
  function handleCredentialResponse(response) {
    console.log('Google Sign-In Response:', response);
    
    if (response.credential) {
      const userObj = parseJwt(response.credential);
      console.log('User info:', userObj);
      
      currentUser = userObj;
      document.getElementById('userEmail').textContent = userObj.email || userObj.name || 'Signed in';
      
      getAccessTokenForSheets();
    } else {
      console.error('Sign-in failed');
      document.getElementById('userEmail').textContent = 'Sign-in failed';
    }
  }
  
  function parseJwt(token) {
    try {
      const base64Url = token.split('.')[1];
      const base64 = base64Url.replace(/-/g, '+').replace(/_/g, '/');
      const jsonPayload = decodeURIComponent(atob(base64).split('').map(function(c) {
        return '%' + ('00' + c.charCodeAt(0).toString(16)).slice(-2);
      }).join(''));
      return JSON.parse(jsonPayload);
    } catch (e) {
      console.error('Error parsing JWT:', e);
      return {};
    }
  }
  
  function getAccessTokenForSheets() {
    console.log('Requesting Sheets API access token...');
    
    const tokenClient = google.accounts.oauth2.initTokenClient({
      client_id: CLIENT_ID,
      scope: 'https://www.googleapis.com/auth/spreadsheets.readonly',
      callback: async (tokenResponse) => {
        if (tokenResponse.error) {
          console.error('Token error:', tokenResponse);
          alert('Failed to get access: ' + tokenResponse.error_description);
          return;
        }
        
        console.log('Got access token!');
        accessToken = tokenResponse.access_token;
        await loadData(accessToken);
      }
    });
    
    tokenClient.requestAccessToken({ prompt: 'consent' });
  }
  
  function reloadData() {
    if (accessToken) {
      loadData(accessToken);
    } else if (currentUser) {
      getAccessTokenForSheets();
    } else {
      loadData(null); // Load sample data
    }
  }
  
  function signOut() {
    if (currentUser) {
      google.accounts.id.disableAutoSelect();
      google.accounts.id.revoke(currentUser.email, () => {
        console.log('User signed out');
      });
    }
    
    currentUser = null;
    accessToken = null;
    document.getElementById('userEmail').textContent = 'not signed in';
    
    objects.forEach(o => scene.remove(o));
    objects = [];
    loadGoogleSignIn();
  }
  
  /* ----------------- Minimal Tween ----------------- */
  !function(global){var TWEEN={_tweens:[],getAll:function(){return TWEEN._tweens},removeAll:function(){TWEEN._tweens=[]},add:function(t){TWEEN._tweens.push(t)},remove:function(t){var i=TWEEN._tweens.indexOf(t);if(i!==-1)TWEEN._tweens.splice(i,1)},update:function(time){if(TWEEN._tweens.length===0)return false;time=time!==undefined?time:Date.now();var i=0;while(i<TWEEN._tweens.length){if(TWEEN._tweens[i].update(time))i++;else TWEEN._tweens.splice(i,1)}return true}};TWEEN.Tween=function(object){this.object=object;this.valuesStart={};this.valuesEnd={};this.duration=1000;this.easing=function(k){return k};this.startTime=null;for(var field in object)this.valuesStart[field]=parseFloat(object[field],10)||0};TWEEN.Tween.prototype.to=function(properties,duration){this.valuesEnd=properties;if(duration!==undefined)this.duration=duration;return this};TWEEN.Tween.prototype.start=function(time){TWEEN.add(this);this.startTime=time!==undefined?time:Date.now();for(var property in this.valuesEnd){if(this.object[property]===undefined)continue;this.valuesStart[property]=this.object[property];}return this};TWEEN.Tween.prototype.easing=function(fn){this.easing=fn;return this};TWEEN.Tween.prototype.update=function(time){if(time<this.startTime)return true;var elapsed=(time-this.startTime)/this.duration;elapsed=elapsed>1?1:elapsed;var value=this.easing(elapsed);for(var property in this.valuesEnd){var start=this.valuesStart[property]||0;var end=this.valuesEnd[property];this.object[property]=start+(end-start)*value;}if(elapsed==1){return false}return true};TWEEN.Easing={Exponential:{InOut:function(k){if((k*=2)<1)return 0.5*Math.pow(2,10*(k-1));return 0.5*(-Math.pow(2,-10*(k-1))+2)}}};global.TWEEN=TWEEN}(this);
  </script>
</body>
</html>
